{"version":3,"file":"utils.js","sourceRoot":"","sources":["../../../src/utils/utils.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport fs from \"node:fs\";\nimport util from \"node:util\";\n\n/**\n * Reads a readable stream into buffer. Fill the buffer from offset to end.\n *\n * @param stream - A Node.js Readable stream\n * @param buffer - Buffer to be filled, length must greater than or equal to offset\n * @param offset - From which position in the buffer to be filled, inclusive\n * @param end - To which position in the buffer to be filled, exclusive\n * @param encoding - Encoding of the Readable stream\n */\nexport async function streamToBuffer(\n  stream: NodeJS.ReadableStream,\n  buffer: Buffer,\n  offset: number,\n  end: number,\n  encoding?: BufferEncoding,\n): Promise<void> {\n  let pos = 0; // Position in stream\n  const count = end - offset; // Total amount of data needed in stream\n\n  return new Promise<void>((resolve, reject) => {\n    stream.on(\"readable\", () => {\n      if (pos >= count) {\n        resolve();\n        return;\n      }\n\n      let chunk = stream.read();\n      if (!chunk) {\n        return;\n      }\n      if (typeof chunk === \"string\") {\n        chunk = Buffer.from(chunk, encoding);\n      }\n\n      // How much data needed in this chunk\n      const chunkLength = pos + chunk.length > count ? count - pos : chunk.length;\n\n      buffer.fill(chunk.slice(0, chunkLength), offset + pos, offset + pos + chunkLength);\n      pos += chunkLength;\n    });\n\n    stream.on(\"end\", () => {\n      if (pos < count) {\n        reject(\n          new Error(\n            `Stream drains before getting enough data needed. Data read: ${pos}, data need: ${count}`,\n          ),\n        );\n      }\n      resolve();\n    });\n\n    stream.on(\"error\", reject);\n  });\n}\n\n/**\n * Reads a readable stream into buffer entirely.\n *\n * @param stream - A Node.js Readable stream\n * @param buffer - Buffer to be filled, length must greater than or equal to offset\n * @param encoding - Encoding of the Readable stream\n * @returns with the count of bytes read.\n * @throws `RangeError` If buffer size is not big enough.\n */\nexport async function streamToBuffer2(\n  stream: NodeJS.ReadableStream,\n  buffer: Buffer,\n  encoding?: BufferEncoding,\n): Promise<number> {\n  let pos = 0; // Position in stream\n  const bufferSize = buffer.length;\n\n  return new Promise<number>((resolve, reject) => {\n    stream.on(\"readable\", () => {\n      let chunk = stream.read();\n      if (!chunk) {\n        return;\n      }\n      if (typeof chunk === \"string\") {\n        chunk = Buffer.from(chunk, encoding);\n      }\n\n      if (pos + chunk.length > bufferSize) {\n        reject(new Error(`Stream exceeds buffer size. Buffer size: ${bufferSize}`));\n        return;\n      }\n\n      buffer.fill(chunk, pos, pos + chunk.length);\n      pos += chunk.length;\n    });\n\n    stream.on(\"end\", () => {\n      resolve(pos);\n    });\n\n    stream.on(\"error\", reject);\n  });\n}\n\n/**\n * ONLY AVAILABLE IN NODE.JS RUNTIME.\n *\n * Promisified version of fs.stat().\n */\nexport const fsStat = util.promisify(fs.stat);\n\nexport const fsCreateReadStream = fs.createReadStream;\n"]}