{"version":3,"file":"clients.js","sourceRoot":"","sources":["../../src/clients.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport type { TokenCredential } from \"@azure/core-auth\";\nimport { isTokenCredential } from \"@azure/core-auth\";\nimport type { RequestBodyType as HttpRequestBody } from \"@azure/core-rest-pipeline\";\nimport { isNodeLike } from \"@azure/core-util\";\nimport type { Pipeline, StoragePipelineOptions } from \"./Pipeline.js\";\nimport { isPipelineLike, newPipeline } from \"./Pipeline.js\";\nimport { BlobClient, BlockBlobClient } from \"@azure/storage-blob\";\nimport { AnonymousCredential } from \"@azure/storage-blob\";\nimport { StorageSharedKeyCredential } from \"./credentials/StorageSharedKeyCredential.js\";\nimport type { Readable } from \"node:stream\";\nimport { BufferScheduler } from \"@azure/storage-common\";\nimport { DataLakeLeaseClient } from \"./DataLakeLeaseClient.js\";\nimport { PathOperationsImpl as Path } from \"./generated/src/operations/index.js\";\nimport type {\n  AccessControlChanges,\n  DirectoryCreateIfNotExistsOptions,\n  DirectoryCreateIfNotExistsResponse,\n  DirectoryCreateOptions,\n  DirectoryCreateResponse,\n  DirectoryGenerateSasUrlOptions,\n  FileAppendOptions,\n  FileAppendResponse,\n  FileCreateIfNotExistsOptions,\n  FileCreateIfNotExistsResponse,\n  FileCreateOptions,\n  FileCreateResponse,\n  FileExpiryMode,\n  FileFlushOptions,\n  FileFlushResponse,\n  FileGenerateSasUrlOptions,\n  FileParallelUploadOptions,\n  FileQueryOptions,\n  FileReadOptions,\n  FileReadResponse,\n  FileReadToBufferOptions,\n  FileSetExpiryOptions,\n  FileSetExpiryResponse,\n  FileUploadResponse,\n  Metadata,\n  PathAccessControlItem,\n  PathChangeAccessControlRecursiveOptions,\n  PathChangeAccessControlRecursiveResponse,\n  PathCreateIfNotExistsOptions,\n  PathCreateIfNotExistsResponse,\n  PathCreateOptions,\n  PathCreateResponse,\n  PathDeleteIfExistsResponse,\n  PathDeleteOptions,\n  PathDeleteResponse,\n  PathExistsOptions,\n  PathGetAccessControlOptions,\n  PathGetAccessControlResponse,\n  PathGetPropertiesOptions,\n  PathGetPropertiesResponse,\n  PathHttpHeaders,\n  PathMoveOptions,\n  PathMoveResponse,\n  PathPermissions,\n  PathResourceTypeModel,\n  PathSetAccessControlOptions,\n  PathSetAccessControlResponse,\n  PathSetHttpHeadersOptions,\n  PathSetHttpHeadersResponse,\n  PathSetMetadataOptions,\n  PathSetMetadataResponse,\n  PathSetPermissionsOptions,\n  PathSetPermissionsResponse,\n  RemovePathAccessControlItem,\n  UserDelegationKey,\n} from \"./models.js\";\nimport type { PathSetAccessControlRecursiveMode } from \"./models.internal.js\";\nimport {\n  generateDataLakeSASQueryParameters,\n  generateDataLakeSASQueryParametersInternal,\n} from \"./sas/DataLakeSASSignatureValues.js\";\nimport { StorageClient } from \"./StorageClient.js\";\nimport {\n  toAccessControlChangeFailureArray,\n  toAcl,\n  toAclString,\n  toBlobCpkInfo,\n  toPermissions,\n  toPermissionsString,\n  toProperties,\n} from \"./transforms.js\";\nimport { Batch } from \"./utils/Batch.js\";\nimport {\n  BLOCK_BLOB_MAX_BLOCKS,\n  DEFAULT_HIGH_LEVEL_CONCURRENCY,\n  ETagAny,\n  FILE_MAX_SINGLE_UPLOAD_THRESHOLD,\n  FILE_MAX_SIZE_BYTES,\n  FILE_UPLOAD_DEFAULT_CHUNK_SIZE,\n  FILE_UPLOAD_MAX_CHUNK_SIZE,\n} from \"./utils/constants.js\";\nimport { DataLakeAclChangeFailedError } from \"./utils/DataLakeAclChangeFailedError.js\";\nimport { tracingClient } from \"./utils/tracing.js\";\nimport {\n  appendToURLPath,\n  appendToURLQuery,\n  assertResponse,\n  ensureCpkIfSpecified,\n  getURLPathAndQuery,\n  ParsePathGetPropertiesExtraHeaderValues,\n  setURLPath,\n  setURLQueries,\n} from \"./utils/utils.common.js\";\nimport { fsCreateReadStream, fsStat } from \"./utils/utils.js\";\nimport type {\n  PathAppendDataHeaders,\n  PathCreateHeaders,\n  PathDeleteHeaders,\n  PathFlushDataHeaders,\n  PathGetPropertiesHeaders,\n  PathSetAccessControlHeaders,\n  PathSetExpiryHeaders,\n} from \"./generated/src/index.js\";\n\n/**\n * A DataLakePathClient represents a URL to the Azure Storage path (directory or file).\n */\nexport class DataLakePathClient extends StorageClient {\n  /**\n   * pathContext provided by protocol layer.\n   */\n  private pathContext: Path;\n\n  /**\n   * blobClient provided by `@azure/storage-blob` package.\n   */\n  private blobClient: BlobClient;\n\n  private isTokenCredential?: boolean;\n\n  /**\n   * SetAccessControlRecursiveInternal operation sets the Access Control on a path and sub paths.\n   *\n   * @param mode - Mode \\\"set\\\" sets POSIX access control rights on files and directories,\n   *                                                 Mode \\\"modify\\\" modifies one or more POSIX access control rights that pre-exist on files and directories,\n   *                                                 Mode \\\"remove\\\" removes one or more POSIX access control rights that were present earlier on files and directories.\n   * @param acl - The POSIX access control list for the file or directory.\n   * @param options - Optional. Options\n   */\n  private async setAccessControlRecursiveInternal(\n    mode: PathSetAccessControlRecursiveMode,\n    acl: PathAccessControlItem[] | RemovePathAccessControlItem[],\n    options: PathChangeAccessControlRecursiveOptions = {},\n  ): Promise<PathChangeAccessControlRecursiveResponse> {\n    if (options.maxBatches !== undefined && options.maxBatches < 1) {\n      throw RangeError(`Options maxBatches must be larger than 0.`);\n    }\n\n    if (options.batchSize !== undefined && options.batchSize < 1) {\n      throw RangeError(`Options batchSize must be larger than 0.`);\n    }\n\n    const result: PathChangeAccessControlRecursiveResponse = {\n      counters: {\n        failedChangesCount: 0,\n        changedDirectoriesCount: 0,\n        changedFilesCount: 0,\n      },\n      continuationToken: undefined,\n    };\n\n    return tracingClient.withSpan(\n      \"DataLakePathClient-setAccessControlRecursiveInternal\",\n      options,\n      async (updatedOptions) => {\n        let continuationToken = options.continuationToken;\n        let batchCounter = 0;\n        let reachMaxBatches = false;\n        do {\n          let response;\n          try {\n            response = await this.pathContext.setAccessControlRecursive(mode, {\n              ...updatedOptions,\n              acl: toAclString(acl as PathAccessControlItem[]),\n              maxRecords: options.batchSize,\n              continuation: continuationToken,\n              forceFlag: options.continueOnFailure,\n            });\n          } catch (e: any) {\n            throw new DataLakeAclChangeFailedError(e, continuationToken);\n          }\n\n          batchCounter++;\n          continuationToken = response.continuation;\n\n          // Update result\n          result.continuationToken = continuationToken;\n          result.counters.failedChangesCount += response.failureCount ?? 0;\n          result.counters.changedDirectoriesCount += response.directoriesSuccessful ?? 0;\n          result.counters.changedFilesCount += response.filesSuccessful ?? 0;\n\n          // Progress event call back\n          if (options.onProgress) {\n            const progress: AccessControlChanges = {\n              batchFailures: toAccessControlChangeFailureArray(response.failedEntries),\n              batchCounters: {\n                failedChangesCount: response.failureCount ?? 0,\n                changedDirectoriesCount: response.directoriesSuccessful ?? 0,\n                changedFilesCount: response.filesSuccessful ?? 0,\n              },\n              aggregateCounters: result.counters,\n              continuationToken: continuationToken,\n            };\n            options.onProgress(progress);\n          }\n\n          reachMaxBatches =\n            options.maxBatches === undefined ? false : batchCounter >= options.maxBatches;\n        } while (continuationToken && !reachMaxBatches);\n\n        return result;\n      },\n    );\n  }\n\n  /**\n   * Creates an instance of DataLakePathClient from url and credential.\n   *\n   * @param url - A Client string pointing to Azure Storage data lake path (directory or file), such as\n   *                     \"https://myaccount.dfs.core.windows.net/filesystem/directory\" or \"https://myaccount.dfs.core.windows.net/filesystem/file\".\n   *                     You can append a SAS if using AnonymousCredential, such as \"https://myaccount.dfs.core.windows.net/filesystem/directory?sasString\".\n   * @param credential - Such as AnonymousCredential, StorageSharedKeyCredential or any credential from the `@azure/identity` package to authenticate requests to the service. You can also provide an object that implements the TokenCredential interface. If not specified, AnonymousCredential is used.\n   * @param options - Optional. Options to configure the HTTP pipeline.\n   */\n  public constructor(\n    url: string,\n    credential?: StorageSharedKeyCredential | AnonymousCredential | TokenCredential,\n    // Legacy, no way to fix the eslint error without breaking. Disable the rule for this line.\n    /* eslint-disable-next-line @azure/azure-sdk/ts-naming-options */\n    options?: StoragePipelineOptions,\n  );\n\n  /**\n   * Creates an instance of DataLakePathClient from url and pipeline.\n   *\n   * @param url - A Client string pointing to Azure Storage data lake path (directory or file), such as\n   *                     \"https://myaccount.dfs.core.windows.net/filesystem/directory\" or \"https://myaccount.dfs.core.windows.net/filesystem/file\".\n   *                     You can append a SAS if using AnonymousCredential, such as \"https://myaccount.dfs.core.windows.net/filesystem/directory?sasString\".\n   * @param pipeline - Call newPipeline() to create a default\n   *                            pipeline, or provide a customized pipeline.\n   */\n  public constructor(url: string, pipeline: Pipeline);\n\n  public constructor(\n    url: string,\n    credentialOrPipeline?:\n      | StorageSharedKeyCredential\n      | AnonymousCredential\n      | TokenCredential\n      | Pipeline,\n    // Legacy, no way to fix the eslint error without breaking. Disable the rule for this line.\n    /* eslint-disable-next-line @azure/azure-sdk/ts-naming-options */\n    options?: StoragePipelineOptions,\n  ) {\n    if (isPipelineLike(credentialOrPipeline)) {\n      super(url, credentialOrPipeline);\n    } else {\n      let credential;\n      if (credentialOrPipeline === undefined) {\n        credential = new AnonymousCredential();\n      } else {\n        credential = credentialOrPipeline;\n      }\n\n      const pipeline = newPipeline(credential, options);\n      super(url, pipeline);\n    }\n\n    this.pathContext = new Path(this.storageClientContext);\n    this.blobClient = new BlobClient(this.blobEndpointUrl, this.pipeline);\n  }\n\n  /**\n   * Name of current file system.\n   *\n   * @readonly\n   */\n  public get fileSystemName(): string {\n    return this.blobClient.containerName;\n  }\n\n  /**\n   * Name of current path (directory or file).\n   *\n   * @readonly\n   */\n  public get name(): string {\n    return this.blobClient.name;\n  }\n\n  /**\n   * Convert current DataLakePathClient to DataLakeDirectoryClient if current path is a directory.\n   *\n   */\n  // Legacy, no way to fix the eslint error without breaking. Disable the rule for this line.\n  /* eslint-disable-next-line @azure/azure-sdk/ts-naming-subclients */\n  public toDirectoryClient(): DataLakeDirectoryClient {\n    return new DataLakeDirectoryClient(this.dfsEndpointUrl, this.pipeline);\n  }\n\n  /**\n   * Convert current DataLakePathClient to DataLakeFileClient if current path is a file.\n   *\n   */\n  // Legacy, no way to fix the eslint error without breaking. Disable the rule for this line.\n  /* eslint-disable-next-line @azure/azure-sdk/ts-naming-subclients */\n  public toFileClient(): DataLakeFileClient {\n    return new DataLakeFileClient(this.dfsEndpointUrl, this.pipeline);\n  }\n\n  /**\n   * Get a {@link DataLakeLeaseClient} that manages leases on the path (directory or file).\n   *\n   * @param proposeLeaseId - Optional. Initial proposed lease Id.\n   */\n  public getDataLakeLeaseClient(proposeLeaseId?: string): DataLakeLeaseClient {\n    return new DataLakeLeaseClient(this.blobClient.getBlobLeaseClient(proposeLeaseId));\n  }\n\n  /**\n   * Create a directory or path.\n   *\n   * @see https://learn.microsoft.com/rest/api/storageservices/datalakestoragegen2/path/create\n   *\n   * @param resourceType - Resource type, \"directory\" or \"file\".\n   * @param options - Optional. Options when creating path.\n   */\n  public async create(\n    resourceType: PathResourceTypeModel,\n    options: PathCreateOptions = {},\n  ): Promise<PathCreateResponse> {\n    options.conditions = options.conditions || {};\n    return tracingClient.withSpan(\"DataLakePathClient-create\", options, async (updatedOptions) => {\n      ensureCpkIfSpecified(options.customerProvidedKey, this.isHttps);\n      let expiryOptions: FileExpiryMode | undefined;\n      let expiresOn: string | undefined;\n      if (typeof options.expiresOn === \"number\" && Number.isFinite(options.expiresOn)) {\n        expiryOptions = \"RelativeToNow\";\n        expiresOn = String(Math.round(options.expiresOn));\n      } else if (options.expiresOn instanceof Date) {\n        expiryOptions = \"Absolute\";\n        expiresOn = options.expiresOn.toUTCString();\n      } else if (options.expiresOn) {\n        throw new Error(`Value for expiresOn is invalid: ${options.expiresOn}`);\n      }\n\n      return assertResponse<PathCreateHeaders, PathCreateHeaders>(\n        await this.pathContext.create({\n          ...updatedOptions,\n          resource: resourceType,\n          leaseAccessConditions: options.conditions,\n          modifiedAccessConditions: options.conditions,\n          properties: toProperties(options.metadata),\n          cpkInfo: options.customerProvidedKey,\n          acl: options.acl ? toAclString(options.acl) : undefined,\n          expiryOptions,\n          expiresOn,\n        }),\n      );\n    });\n  }\n\n  /**\n   * Create a directory or file. If the resource already exists, it is not changed.\n   *\n   * @see https://learn.microsoft.com/rest/api/storageservices/datalakestoragegen2/path/create\n   *\n   * @param resourceType - Resource type, \"directory\" or \"file\".\n   * @param options -\n   */\n  public async createIfNotExists(\n    resourceType: PathResourceTypeModel,\n    options: PathCreateIfNotExistsOptions = {},\n  ): Promise<PathCreateIfNotExistsResponse> {\n    return tracingClient.withSpan(\n      \"DataLakePathClient-createIfNotExists\",\n      options,\n      async (updatedOptions) => {\n        try {\n          const conditions = { ifNoneMatch: ETagAny };\n          const res = await this.create(resourceType, {\n            ...options,\n            conditions,\n            tracingOptions: updatedOptions.tracingOptions,\n          });\n          return {\n            succeeded: true,\n            ...res,\n          };\n        } catch (e: any) {\n          if (e.details?.errorCode === \"PathAlreadyExists\") {\n            return {\n              succeeded: false,\n              ...e.response?.parsedHeaders,\n              _response: e.response,\n            };\n          }\n          throw e;\n        }\n      },\n    );\n  }\n\n  /**\n   * Returns true if the Data Lake file represented by this client exists; false otherwise.\n   *\n   * NOTE: use this function with care since an existing file might be deleted by other clients or\n   * applications. Vice versa new files might be added by other clients or applications after this\n   * function completes.\n   *\n   * @param options - options to Exists operation.\n   */\n  public async exists(options: PathExistsOptions = {}): Promise<boolean> {\n    return tracingClient.withSpan(\"DataLakeFileClient-exists\", options, async (updatedOptions) => {\n      return this.blobClient.exists({\n        ...updatedOptions,\n        customerProvidedKey: toBlobCpkInfo(updatedOptions.customerProvidedKey),\n      });\n    });\n  }\n\n  /**\n   * Delete current path (directory or file).\n   *\n   * @see https://learn.microsoft.com/rest/api/storageservices/datalakestoragegen2/path/delete\n   *\n   * @param recursive - Required and valid only when the resource is a directory. If \"true\", all paths beneath the directory will be deleted.\n   * @param options - Optional. Options when deleting path.\n   */\n  public async delete(\n    recursive?: boolean,\n    options: PathDeleteOptions = {},\n  ): Promise<PathDeleteResponse> {\n    options.conditions = options.conditions || {};\n    return tracingClient.withSpan(\"DataLakePathClient-delete\", options, async (updatedOptions) => {\n      if (this.isTokenCredential === undefined) {\n        this.isTokenCredential = false;\n        this.pipeline.factories.forEach((factory) => {\n          if (isTokenCredential((factory as any).credential)) {\n            this.isTokenCredential = true;\n          }\n        });\n\n        if (isTokenCredential((this.pipeline as any)._credential)) {\n          this.isTokenCredential = true;\n        }\n      }\n      const paginated = recursive === true && this.isTokenCredential === true;\n      let continuation: string | undefined;\n      let response: PathDeleteResponse;\n\n      // How to handle long delete loop?\n      do {\n        response = assertResponse<PathDeleteHeaders, PathDeleteHeaders>(\n          await this.pathContext.delete({\n            ...updatedOptions,\n            continuation,\n            recursive,\n            leaseAccessConditions: options.conditions,\n            modifiedAccessConditions: options.conditions,\n            abortSignal: options.abortSignal,\n            paginated,\n          }),\n        );\n        continuation = response.continuation;\n      } while (continuation);\n\n      return response;\n    });\n  }\n\n  /**\n   * Delete current path (directory or file) if it exists.\n   *\n   * @see https://learn.microsoft.com/rest/api/storageservices/datalakestoragegen2/path/delete\n   *\n   * @param recursive - Required and valid only when the resource is a directory. If \"true\", all paths beneath the directory will be deleted.\n   * @param options -\n   */\n  public async deleteIfExists(\n    recursive?: boolean,\n    options: PathDeleteOptions = {},\n  ): Promise<PathDeleteIfExistsResponse> {\n    options.conditions = options.conditions || {};\n    return tracingClient.withSpan(\n      \"DataLakePathClient-deleteIfExists\",\n      options,\n      async (updatedOptions) => {\n        try {\n          const res = await this.delete(recursive, updatedOptions);\n          return {\n            succeeded: true,\n            ...res,\n          };\n        } catch (e: any) {\n          if (e.details?.errorCode === \"PathNotFound\") {\n            return {\n              succeeded: false,\n              ...e.response?.parsedHeaders,\n              _response: e.response,\n            };\n          }\n          throw e;\n        }\n      },\n    );\n  }\n\n  /**\n   * Returns the access control data for a path (directory of file).\n   *\n   * @see https://learn.microsoft.com/rest/api/storageservices/datalakestoragegen2/path/getproperties\n   *\n   * @param options - Optional. Options when getting file access control.\n   */\n  public async getAccessControl(\n    options: PathGetAccessControlOptions = {},\n  ): Promise<PathGetAccessControlResponse> {\n    options.conditions = options.conditions || {};\n    return tracingClient.withSpan(\n      \"DataLakePathClient-getAccessControl\",\n      options,\n      async (updatedOptions) => {\n        const response = assertResponse<PathGetPropertiesHeaders, PathGetPropertiesHeaders>(\n          await this.pathContext.getProperties({\n            ...updatedOptions,\n            action: \"getAccessControl\",\n            upn: options.userPrincipalName,\n            leaseAccessConditions: options.conditions,\n            modifiedAccessConditions: options.conditions,\n            abortSignal: options.abortSignal,\n          }),\n        );\n        return {\n          ...response,\n          _response: response._response,\n          permissions: toPermissions(response.permissions),\n          acl: toAcl(response.acl),\n        };\n      },\n    );\n  }\n\n  /**\n   * Set the access control data for a path (directory of file).\n   *\n   * @see https://learn.microsoft.com/rest/api/storageservices/datalakestoragegen2/path/update\n   *\n   * @param acl - The POSIX access control list for the file or directory.\n   * @param options - Optional. Options when setting path access control.\n   */\n  public async setAccessControl(\n    acl: PathAccessControlItem[],\n    options: PathSetAccessControlOptions = {},\n  ): Promise<PathSetAccessControlResponse> {\n    options.conditions = options.conditions || {};\n    return tracingClient.withSpan(\n      \"DataLakePathClient-setAccessControl\",\n      options,\n      async (updatedOptions) => {\n        return assertResponse<PathSetAccessControlHeaders, PathSetAccessControlHeaders>(\n          await this.pathContext.setAccessControl({\n            ...updatedOptions,\n            acl: toAclString(acl),\n            leaseAccessConditions: options.conditions,\n            modifiedAccessConditions: options.conditions,\n          }),\n        );\n      },\n    );\n  }\n\n  /**\n   * Sets the Access Control on a path and sub paths.\n   *\n   * @see https://learn.microsoft.com/rest/api/storageservices/datalakestoragegen2/path/update\n   *\n   * @param acl - The POSIX access control list for the file or directory.\n   * @param options - Optional. Options\n   */\n  public async setAccessControlRecursive(\n    acl: PathAccessControlItem[],\n    options: PathChangeAccessControlRecursiveOptions = {},\n  ): Promise<PathChangeAccessControlRecursiveResponse> {\n    return tracingClient.withSpan(\n      \"DataLakePathClient-setAccessControlRecursive\",\n      options,\n      async (updatedOptions) => {\n        return this.setAccessControlRecursiveInternal(\"set\", acl, updatedOptions);\n      },\n    );\n  }\n\n  /**\n   * Modifies the Access Control on a path and sub paths.\n   *\n   * @see https://learn.microsoft.com/rest/api/storageservices/datalakestoragegen2/path/update\n   *\n   * @param acl - The POSIX access control list for the file or directory.\n   * @param options - Optional. Options\n   */\n  public async updateAccessControlRecursive(\n    acl: PathAccessControlItem[],\n    options: PathChangeAccessControlRecursiveOptions = {},\n  ): Promise<PathChangeAccessControlRecursiveResponse> {\n    return tracingClient.withSpan(\n      \"DataLakePathClient-updateAccessControlRecursive\",\n      options,\n      async (updatedOptions) => {\n        return this.setAccessControlRecursiveInternal(\"modify\", acl, updatedOptions);\n      },\n    );\n  }\n\n  /**\n   * Removes the Access Control on a path and sub paths.\n   *\n   * @see https://learn.microsoft.com/rest/api/storageservices/datalakestoragegen2/path/update\n   *\n   * @param acl - The POSIX access control list for the file or directory.\n   * @param options - Optional. Options\n   */\n  public async removeAccessControlRecursive(\n    acl: RemovePathAccessControlItem[],\n    options: PathChangeAccessControlRecursiveOptions = {},\n  ): Promise<PathChangeAccessControlRecursiveResponse> {\n    return tracingClient.withSpan(\n      \"DataLakePathClient-removeAccessControlRecursive\",\n      options,\n      async (updatedOptions) => {\n        return this.setAccessControlRecursiveInternal(\"remove\", acl, updatedOptions);\n      },\n    );\n  }\n\n  /**\n   * Sets the file permissions on a path.\n   *\n   * @see https://learn.microsoft.com/rest/api/storageservices/datalakestoragegen2/path/update\n   *\n   * @param permissions - The POSIX access permissions for the file owner, the file owning group, and others.\n   * @param options - Optional. Options when setting path permissions.\n   */\n  public async setPermissions(\n    permissions: PathPermissions,\n    options: PathSetPermissionsOptions = {},\n  ): Promise<PathSetPermissionsResponse> {\n    options.conditions = options.conditions || {};\n    return tracingClient.withSpan(\n      \"DataLakePathClient-setPermissions\",\n      options,\n      async (updatedOptions) => {\n        return assertResponse<PathSetAccessControlHeaders, PathSetAccessControlHeaders>(\n          await this.pathContext.setAccessControl({\n            ...updatedOptions,\n            permissions: toPermissionsString(permissions),\n            leaseAccessConditions: options.conditions,\n            modifiedAccessConditions: options.conditions,\n          }),\n        );\n      },\n    );\n  }\n\n  /**\n   * Returns all user-defined metadata, standard HTTP properties, and system properties\n   * for the path (directory or file).\n   *\n   * WARNING: The `metadata` object returned in the response will have its keys in lowercase, even if\n   * they originally contained uppercase characters. This differs from the metadata keys returned by\n   * the methods of {@link DataLakeFileSystemClient} that list paths using the `includeMetadata` option, which\n   * will retain their original casing.\n   *\n   * @see https://learn.microsoft.com/rest/api/storageservices/get-blob-properties\n   *\n   * @param options - Optional. Options when getting path properties.\n   */\n  public async getProperties(\n    options: PathGetPropertiesOptions = {},\n  ): Promise<PathGetPropertiesResponse> {\n    return tracingClient.withSpan(\n      \"DataLakePathClient-getProperties\",\n      options,\n      async (updatedOptions) => {\n        const response = await this.blobClient.getProperties({\n          ...options,\n          customerProvidedKey: toBlobCpkInfo(options.customerProvidedKey),\n          tracingOptions: updatedOptions.tracingOptions,\n        });\n        return ParsePathGetPropertiesExtraHeaderValues(response as PathGetPropertiesResponse);\n      },\n    );\n  }\n\n  /**\n   * Sets system properties on the path (directory or file).\n   *\n   * If no value provided, or no value provided for the specified blob HTTP headers,\n   * these blob HTTP headers without a value will be cleared.\n   * @see https://learn.microsoft.com/rest/api/storageservices/set-blob-properties\n   *\n   * @param httpHeaders -\n   * @param options -\n   */\n  public async setHttpHeaders(\n    httpHeaders: PathHttpHeaders,\n    options: PathSetHttpHeadersOptions = {},\n  ): Promise<PathSetHttpHeadersResponse> {\n    return tracingClient.withSpan(\n      \"DataLakePathClient-setHttpHeaders\",\n      options,\n      async (updatedOptions) => {\n        return this.blobClient.setHTTPHeaders(\n          {\n            blobCacheControl: httpHeaders.cacheControl,\n            blobContentType: httpHeaders.contentType,\n            blobContentMD5: httpHeaders.contentMD5,\n            blobContentEncoding: httpHeaders.contentEncoding,\n            blobContentLanguage: httpHeaders.contentLanguage,\n            blobContentDisposition: httpHeaders.contentDisposition,\n          },\n          updatedOptions,\n        );\n      },\n    );\n  }\n\n  /**\n   * Sets user-defined metadata for the specified path (directory of file) as one or more name-value pairs.\n   *\n   * If no option provided, or no metadata defined in the parameter, the path\n   * metadata will be removed.\n   *\n   * @see https://learn.microsoft.com/rest/api/storageservices/set-blob-metadata\n   *\n   * @param metadata - Optional. Replace existing metadata with this value.\n   *                              If no value provided the existing metadata will be removed.\n   * @param options - Optional. Options when setting path metadata.\n   */\n  public async setMetadata(\n    metadata?: Metadata,\n    options: PathSetMetadataOptions = {},\n  ): Promise<PathSetMetadataResponse> {\n    return tracingClient.withSpan(\n      \"DataLakePathClient-setMetadata\",\n      options,\n      async (updatedOptions) => {\n        return this.blobClient.setMetadata(metadata, {\n          ...options,\n          customerProvidedKey: toBlobCpkInfo(options.customerProvidedKey),\n          tracingOptions: updatedOptions.tracingOptions,\n        });\n      },\n    );\n  }\n\n  /**\n   * Move directory or file within same file system.\n   *\n   * @see https://learn.microsoft.com/rest/api/storageservices/datalakestoragegen2/path/create\n   *\n   * @param destinationPath - Destination directory path like \"directory\" or file path \"directory/file\".\n   *                                 If the destinationPath is authenticated with SAS, add the SAS to the destination path like \"directory/file?sasToken\".\n   * @param options - Optional. Options when moving directory or file.\n   */\n  public async move(destinationPath: string, options?: PathMoveOptions): Promise<PathMoveResponse>;\n\n  /**\n   * Move directory or file to another file system.\n   *\n   * @see https://learn.microsoft.com/rest/api/storageservices/datalakestoragegen2/path/create\n   *\n   * @param destinationFileSystem - Destination file system like \"filesystem\".\n   * @param destinationPath - Destination directory path like \"directory\" or file path \"directory/file\"\n   *                                 If the destinationPath is authenticated with SAS, add the SAS to the destination path like \"directory/file?sasToken\".\n   * @param options - Optional. Options when moving directory or file.\n   */\n  public async move(\n    destinationFileSystem: string,\n    destinationPath: string,\n    options?: PathMoveOptions,\n  ): Promise<PathMoveResponse>;\n\n  public async move(\n    destinationPathOrFileSystem: string,\n    destinationPathOrOptions?: string | PathMoveOptions,\n    options?: PathMoveOptions,\n  ): Promise<PathMoveResponse> {\n    let destinationFileSystem = this.fileSystemName;\n    let destinationPath = destinationPathOrFileSystem;\n    let pathMoveOptions: PathMoveOptions;\n\n    if (typeof destinationPathOrOptions === \"string\") {\n      destinationFileSystem = destinationPathOrFileSystem;\n      destinationPath = destinationPathOrOptions;\n      pathMoveOptions = options ?? {};\n    } else {\n      pathMoveOptions = destinationPathOrOptions ?? {};\n    }\n\n    const renameSource = getURLPathAndQuery(this.dfsEndpointUrl);\n\n    const split: string[] = destinationPath.split(\"?\");\n    let destinationUrl: string;\n    if (split.length === 2) {\n      const renameDestination = `/${destinationFileSystem}/${split[0]}`;\n      destinationUrl = setURLPath(this.dfsEndpointUrl, renameDestination);\n      destinationUrl = setURLQueries(destinationUrl, split[1]);\n    } else if (split.length === 1) {\n      const renameDestination = `/${destinationFileSystem}/${destinationPath}`;\n      destinationUrl = setURLPath(this.dfsEndpointUrl, renameDestination);\n    } else {\n      throw new RangeError(\"Destination path should not contain more than one query string\");\n    }\n\n    const destPathClient = new DataLakePathClient(destinationUrl, this.pipeline);\n\n    return tracingClient.withSpan(\n      \"DataLakePathClient-move\",\n      pathMoveOptions,\n      async (updatedOptions) => {\n        return assertResponse<PathCreateHeaders, PathCreateHeaders>(\n          await destPathClient.pathContext.create({\n            ...updatedOptions,\n            mode: \"legacy\", // By default\n            renameSource,\n            sourceLeaseId: pathMoveOptions.conditions?.leaseId,\n            leaseAccessConditions: pathMoveOptions.destinationConditions,\n            sourceModifiedAccessConditions: {\n              sourceIfMatch: pathMoveOptions.conditions?.ifMatch,\n              sourceIfNoneMatch: pathMoveOptions.conditions?.ifNoneMatch,\n              sourceIfModifiedSince: pathMoveOptions.conditions?.ifModifiedSince,\n              sourceIfUnmodifiedSince: pathMoveOptions.conditions?.ifUnmodifiedSince,\n            },\n            modifiedAccessConditions: pathMoveOptions.destinationConditions,\n            abortSignal: pathMoveOptions.abortSignal,\n          }),\n        );\n      },\n    );\n  }\n}\n\n/**\n * A DataLakeDirectoryClient represents a URL to the Azure Storage directory.\n */\nexport class DataLakeDirectoryClient extends DataLakePathClient {\n  // https://stackoverflow.com/questions/50729485/override-method-with-different-argument-types-in-extended-class-typescript\n  /**\n   * Create a directory.\n   *\n   * @see https://learn.microsoft.com/rest/api/storageservices/datalakestoragegen2/path/create\n   *\n   * @param resourceType - Resource type, must be \"directory\" for DataLakeDirectoryClient.\n   * @param options - Optional. Options when creating directory.\n   */\n  public async create(\n    resourceType: PathResourceTypeModel,\n    options?: PathCreateOptions,\n  ): Promise<PathCreateResponse>;\n\n  /**\n   * Create a directory.\n   *\n   * @see https://learn.microsoft.com/rest/api/storageservices/datalakestoragegen2/path/create\n   *\n   * @param options - Optional. Options when creating directory.\n   */\n  public async create(options?: DirectoryCreateOptions): Promise<DirectoryCreateResponse>;\n\n  public async create(\n    resourceTypeOrOptions?: PathResourceTypeModel | PathCreateOptions,\n    options: PathCreateOptions = {},\n  ): Promise<PathCreateResponse> {\n    if (resourceTypeOrOptions === \"file\") {\n      throw TypeError(\n        `DataLakeDirectoryClient:create() resourceType cannot be ${resourceTypeOrOptions}. Refer to DataLakeFileClient for file creation.`,\n      );\n    }\n\n    let pathCreateOptions: PathCreateOptions;\n\n    if (resourceTypeOrOptions === \"directory\") {\n      pathCreateOptions = options;\n    } else {\n      pathCreateOptions = resourceTypeOrOptions ?? {};\n    }\n    return tracingClient.withSpan(\n      \"DataLakeDirectoryClient-create\",\n      pathCreateOptions,\n      async (updatedOptions) => {\n        return super.create(\"directory\", updatedOptions);\n      },\n    );\n  }\n\n  /**\n   * Create a directory if it doesn't already exists.\n   *\n   * @see https://learn.microsoft.com/rest/api/storageservices/datalakestoragegen2/path/create\n   *\n   * @param resourceType - Resource type, must be \"directory\" for DataLakeDirectoryClient.\n   * @param options -\n   */\n  public async createIfNotExists(\n    resourceType: PathResourceTypeModel,\n    options?: PathCreateIfNotExistsOptions,\n  ): Promise<PathCreateIfNotExistsResponse>;\n\n  /**\n   * Create a directory if it doesn't already exists.\n   *\n   * @see https://learn.microsoft.com/rest/api/storageservices/datalakestoragegen2/path/create\n   *\n   * @param options -\n   */\n  public async createIfNotExists(\n    options?: DirectoryCreateIfNotExistsOptions,\n  ): Promise<DirectoryCreateIfNotExistsResponse>;\n\n  public async createIfNotExists(\n    resourceTypeOrOptions?: PathResourceTypeModel | PathCreateIfNotExistsOptions,\n    options: PathCreateIfNotExistsOptions = {},\n  ): Promise<PathCreateIfNotExistsResponse> {\n    if (resourceTypeOrOptions === \"file\") {\n      throw TypeError(\n        `DataLakeDirectoryClient:createIfNotExists() resourceType cannot be ${resourceTypeOrOptions}. Refer to DataLakeFileClient for file creation.`,\n      );\n    }\n\n    if (resourceTypeOrOptions !== \"directory\") {\n      options = resourceTypeOrOptions || {};\n    }\n\n    return tracingClient.withSpan(\n      \"DataLakeDirectoryClient-createIfNotExists\",\n      options,\n      async (updatedOptions) => {\n        return super.createIfNotExists(\"directory\", {\n          ...updatedOptions,\n        });\n      },\n    );\n  }\n\n  /**\n   * Creates a {@link DataLakeDirectoryClient} object under current directory.\n   *\n   * @param subdirectoryName - Subdirectory name.\n   */\n  public getSubdirectoryClient(subdirectoryName: string): DataLakeDirectoryClient {\n    return new DataLakeDirectoryClient(\n      appendToURLPath(this.url, encodeURIComponent(subdirectoryName)),\n      this.pipeline,\n    );\n  }\n\n  /**\n   * Creates a {@link DataLakeFileClient} object under current directory.\n   *\n   * @param fileName -\n   */\n  // Legacy, no way to fix the eslint error without breaking. Disable the rule for this line.\n  /* eslint-disable-next-line @azure/azure-sdk/ts-naming-subclients */\n  public getFileClient(fileName: string): DataLakeFileClient {\n    return new DataLakeFileClient(\n      appendToURLPath(this.url, encodeURIComponent(fileName)),\n      this.pipeline,\n    );\n  }\n\n  /**\n   * Only available for clients constructed with a shared key credential.\n   *\n   * Generates a Service Shared Access Signature (SAS) URI based on the client properties\n   * and parameters passed in. The SAS is signed by the shared key credential of the client.\n   *\n   * @see https://learn.microsoft.com/rest/api/storageservices/constructing-a-service-sas\n   *\n   * @param options - Optional parameters.\n   * @returns The SAS URI consisting of the URI to the resource represented by this client, followed by the generated SAS token.\n   */\n  public generateSasUrl(options: DirectoryGenerateSasUrlOptions): Promise<string> {\n    return new Promise((resolve) => {\n      if (!(this.credential instanceof StorageSharedKeyCredential)) {\n        throw RangeError(\n          \"Can only generate the SAS when the client is initialized with a shared key credential\",\n        );\n      }\n\n      const sas = generateDataLakeSASQueryParameters(\n        {\n          fileSystemName: this.fileSystemName,\n          pathName: this.name,\n          isDirectory: true,\n          ...options,\n        },\n        this.credential,\n      ).toString();\n\n      resolve(appendToURLQuery(this.url, sas));\n    });\n  }\n\n  /**\n   * Generates string to sign for a Service Shared Access Signature (SAS) URI based on the client properties\n   * and parameters passed in.\n   *\n   * @see https://learn.microsoft.com/rest/api/storageservices/constructing-a-service-sas\n   *\n   * @param options - Optional parameters.\n   * @returns The SAS URI consisting of the URI to the resource represented by this client, followed by the generated SAS token.\n   */\n  /* eslint-disable-next-line @azure/azure-sdk/ts-naming-options*/\n  public generateSasStringToSign(options: DirectoryGenerateSasUrlOptions): string {\n    if (!(this.credential instanceof StorageSharedKeyCredential)) {\n      throw RangeError(\n        \"Can only generate the SAS when the client is initialized with a shared key credential\",\n      );\n    }\n    return generateDataLakeSASQueryParametersInternal(\n      {\n        fileSystemName: this.fileSystemName,\n        pathName: this.name,\n        isDirectory: true,\n        ...options,\n      },\n      this.credential,\n    ).stringToSign;\n  }\n\n  /**\n   * Generates a Service Shared Access Signature (SAS) URI based on the client properties\n   * and parameters passed in. The SAS is signed by the input user delegation key.\n   *\n   * @see https://learn.microsoft.com/rest/api/storageservices/constructing-a-service-sas\n   *\n   * @param options - Optional parameters.\n   * @param userDelegationKey - Return value of `blobServiceClient.getUserDelegationKey()`\n   * @returns The SAS URI consisting of the URI to the resource represented by this client, followed by the generated SAS token.\n   */\n  public generateUserDelegationSasUrl(\n    options: DirectoryGenerateSasUrlOptions,\n    userDelegationKey: UserDelegationKey,\n  ): Promise<string> {\n    return new Promise((resolve) => {\n      const sas = generateDataLakeSASQueryParameters(\n        {\n          fileSystemName: this.fileSystemName,\n          pathName: this.name,\n          isDirectory: true,\n          ...options,\n        },\n        userDelegationKey,\n        this.accountName,\n      ).toString();\n\n      resolve(appendToURLQuery(this.url, sas));\n    });\n  }\n\n  /**\n   * Generates string to sign for a Service Shared Access Signature (SAS) URI based on the client properties\n   * and parameters passed in The SAS is signed by the input user delegation key.\n   *\n   * @see https://learn.microsoft.com/rest/api/storageservices/constructing-a-service-sas\n   *\n   * @param options - Optional parameters.\n   * @param userDelegationKey - Return value of `blobServiceClient.getUserDelegationKey()`\n   * @returns The SAS URI consisting of the URI to the resource represented by this client, followed by the generated SAS token.\n   */\n\n  public generateUserDelegationSasStringToSign(\n    options: DirectoryGenerateSasUrlOptions,\n    userDelegationKey: UserDelegationKey,\n  ): string {\n    return generateDataLakeSASQueryParametersInternal(\n      {\n        fileSystemName: this.fileSystemName,\n        pathName: this.name,\n        isDirectory: true,\n        ...options,\n      },\n      userDelegationKey,\n      this.accountName,\n    ).stringToSign;\n  }\n}\n\n/**\n * A DataLakeFileClient represents a URL to the Azure Storage file.\n */\nexport class DataLakeFileClient extends DataLakePathClient {\n  /**\n   * pathContextInternal provided by protocol layer.\n   */\n  private pathContextInternal: Path;\n\n  /**\n   * pathContextInternal provided by protocol layer, with its url pointing to the Blob endpoint.\n   */\n  private pathContextInternalToBlobEndpoint: Path;\n\n  /**\n   * blockBlobClientInternal provided by `@azure/storage-blob` package.\n   */\n  private blockBlobClientInternal: BlockBlobClient;\n\n  /**\n   * Creates an instance of DataLakeFileClient from url and credential.\n   *\n   * @param url - A Client string pointing to Azure Storage data lake file, such as\n   *                     \"https://myaccount.dfs.core.windows.net/filesystem/file\".\n   *                     You can append a SAS if using AnonymousCredential, such as \"https://myaccount.dfs.core.windows.net/filesystem/directory/file?sasString\".\n   * @param credential - Such as AnonymousCredential, StorageSharedKeyCredential or any credential from the `@azure/identity` package to authenticate requests to the service. You can also provide an object that implements the TokenCredential interface. If not specified, AnonymousCredential is used.\n   * @param options - Optional. Options to configure the HTTP pipeline.\n   */\n  public constructor(\n    url: string,\n    credential?: StorageSharedKeyCredential | AnonymousCredential | TokenCredential,\n    // Legacy, no way to fix the eslint error without breaking. Disable the rule for this line.\n    /* eslint-disable-next-line @azure/azure-sdk/ts-naming-options */\n    options?: StoragePipelineOptions,\n  );\n\n  /**\n   * Creates an instance of DataLakeFileClient from url and pipeline.\n   *\n   * @param url - A Client string pointing to Azure Storage data lake file, such as\n   *                     \"https://myaccount.dfs.core.windows.net/filesystem/file\".\n   *                     You can append a SAS if using AnonymousCredential, such as \"https://myaccount.dfs.core.windows.net/filesystem/directory/file?sasString\".\n   * @param pipeline - Call newPipeline() to create a default\n   *                            pipeline, or provide a customized pipeline.\n   */\n  public constructor(url: string, pipeline: Pipeline);\n\n  public constructor(\n    url: string,\n    credentialOrPipeline?:\n      | StorageSharedKeyCredential\n      | AnonymousCredential\n      | TokenCredential\n      | Pipeline,\n    // Legacy, no way to fix the eslint error without breaking. Disable the rule for this line.\n    /* eslint-disable-next-line @azure/azure-sdk/ts-naming-options */\n    options?: StoragePipelineOptions,\n  ) {\n    if (isPipelineLike(credentialOrPipeline)) {\n      super(url, credentialOrPipeline);\n    } else {\n      let credential;\n      if (credentialOrPipeline === undefined) {\n        credential = new AnonymousCredential();\n      } else {\n        credential = credentialOrPipeline;\n      }\n\n      const pipeline = newPipeline(credential, options);\n      super(url, pipeline);\n    }\n\n    this.pathContextInternal = new Path(this.storageClientContext);\n    this.blockBlobClientInternal = new BlockBlobClient(this.blobEndpointUrl, this.pipeline);\n    this.pathContextInternalToBlobEndpoint = new Path(this.storageClientContextToBlobEndpoint);\n  }\n\n  /**\n   * Create a file.\n   *\n   * @see https://learn.microsoft.com/rest/api/storageservices/datalakestoragegen2/path/create\n   *\n   * @param resourceType - Resource type, must be \"file\" for DataLakeFileClient.\n   * @param options - Optional. Options when creating file.\n   */\n  public async create(\n    resourceType: PathResourceTypeModel,\n    options?: PathCreateOptions,\n  ): Promise<PathCreateResponse>;\n\n  /**\n   * Create a file.\n   *\n   * @see https://learn.microsoft.com/rest/api/storageservices/datalakestoragegen2/path/create\n   *\n   * @param options - Optional. Options when creating file.\n   */\n  public async create(options?: FileCreateOptions): Promise<FileCreateResponse>;\n\n  public async create(\n    resourceTypeOrOptions?: PathResourceTypeModel | PathCreateOptions,\n    options: PathCreateOptions = {},\n  ): Promise<PathCreateResponse> {\n    if (resourceTypeOrOptions === \"directory\") {\n      throw TypeError(\n        `DataLakeFileClient:create() resourceType cannot be ${resourceTypeOrOptions}. Refer to DataLakeDirectoryClient for directory creation.`,\n      );\n    }\n\n    let pathCreateOptions: PathCreateOptions;\n    if (resourceTypeOrOptions === \"file\") {\n      pathCreateOptions = options;\n    } else {\n      pathCreateOptions = resourceTypeOrOptions ?? {};\n    }\n\n    return tracingClient.withSpan(\n      \"DataLakeFileClient-create\",\n      pathCreateOptions,\n      async (updatedOptions) => {\n        return super.create(\"file\", updatedOptions);\n      },\n    );\n  }\n\n  /**\n   * Create a file if it doesn't already exists.\n   *\n   * @see https://learn.microsoft.com/rest/api/storageservices/datalakestoragegen2/path/create\n   *\n   * @param resourceType - Resource type, must be \"file\" for DataLakeFileClient.\n   * @param options -\n   */\n  public async createIfNotExists(\n    resourceType: PathResourceTypeModel,\n    options?: PathCreateIfNotExistsOptions,\n  ): Promise<PathCreateIfNotExistsResponse>;\n\n  /**\n   * Create a file if it doesn't already exists.\n   *\n   * @see https://learn.microsoft.com/rest/api/storageservices/datalakestoragegen2/path/create\n   *\n   * @param options - Optional. Options when creating file.\n   */\n  public async createIfNotExists(\n    options?: FileCreateIfNotExistsOptions,\n  ): Promise<FileCreateIfNotExistsResponse>;\n\n  public async createIfNotExists(\n    resourceTypeOrOptions?: PathResourceTypeModel | PathCreateOptions,\n    options: PathCreateIfNotExistsOptions = {},\n  ): Promise<PathCreateIfNotExistsResponse> {\n    if (resourceTypeOrOptions === \"directory\") {\n      throw TypeError(\n        `DataLakeFileClient:createIfNotExists() resourceType cannot be ${resourceTypeOrOptions}. Refer to DataLakeDirectoryClient for directory creation.`,\n      );\n    }\n\n    if (resourceTypeOrOptions !== \"file\") {\n      options = resourceTypeOrOptions || {};\n    }\n\n    return tracingClient.withSpan(\n      \"DataLakeFileClient-createIfNotExists\",\n      options,\n      async (updatedOptions) => {\n        return super.createIfNotExists(\"file\", updatedOptions);\n      },\n    );\n  }\n\n  /**\n   * Downloads a file from the service, including its metadata and properties.\n   *\n   * * In Node.js, data returns in a Readable stream readableStreamBody\n   * * In browsers, data returns in a promise contentAsBlob\n   *\n   * @see https://learn.microsoft.com/rest/api/storageservices/get-blob\n   *\n   * * Example usage (Node.js):\n   *\n   * ```ts snippet:ReadmeSampleDownloadFile_Node\n   * import { DataLakeServiceClient } from \"@azure/storage-file-datalake\";\n   * import { DefaultAzureCredential } from \"@azure/identity\";\n   *\n   * const account = \"<account>\";\n   * const datalakeServiceClient = new DataLakeServiceClient(\n   *   `https://${account}.dfs.core.windows.net`,\n   *   new DefaultAzureCredential(),\n   * );\n   *\n   * const fileSystemName = \"<file system name>\";\n   * const fileName = \"<file name>\";\n   * const fileSystemClient = datalakeServiceClient.getFileSystemClient(fileSystemName);\n   * const fileClient = fileSystemClient.getFileClient(fileName);\n   *\n   * // Get file content from position 0 to the end\n   * // In Node.js, get downloaded data by accessing downloadResponse.readableStreamBody\n   * const downloadResponse = await fileClient.read();\n   * if (downloadResponse.readableStreamBody) {\n   *   const downloaded = await streamToBuffer(downloadResponse.readableStreamBody);\n   *   console.log(\"Downloaded file content:\", downloaded.toString());\n   * }\n   *\n   * // [Node.js only] A helper method used to read a Node.js readable stream into a Buffer.\n   * async function streamToBuffer(readableStream: NodeJS.ReadableStream): Promise<Buffer> {\n   *   return new Promise((resolve, reject) => {\n   *     const chunks: Buffer[] = [];\n   *     readableStream.on(\"data\", (data) => {\n   *       chunks.push(data instanceof Buffer ? data : Buffer.from(data));\n   *     });\n   *     readableStream.on(\"end\", () => {\n   *       resolve(Buffer.concat(chunks));\n   *     });\n   *     readableStream.on(\"error\", reject);\n   *   });\n   * }\n   * ```\n   *\n   * Example usage (browser):\n   *\n   * ```ts snippet:ReadmeSampleDownloadFile_Browser\n   * import { DataLakeServiceClient } from \"@azure/storage-file-datalake\";\n   *\n   * const account = \"<account>\";\n   * const sas = \"<sas token>\";\n   * const datalakeServiceClient = new DataLakeServiceClient(\n   *   `https://${account}.dfs.core.windows.net${sas}`,\n   * );\n   *\n   * const fileSystemName = \"<file system name>\";\n   * const fileName = \"<file name>\";\n   * const fileSystemClient = datalakeServiceClient.getFileSystemClient(fileSystemName);\n   * const fileClient = fileSystemClient.getFileClient(fileName);\n   *\n   * // Get file content from position 0 to the end\n   * // In browsers, get downloaded data by accessing downloadResponse.contentAsBlob\n   * const downloadResponse = await fileClient.read();\n   * if (downloadResponse.contentAsBlob) {\n   *   const blob = await downloadResponse.contentAsBlob;\n   *   const downloaded = await blob.text();\n   *   console.log(`Downloaded file content ${downloaded}`);\n   * }\n   * ```\n   *\n   * @param offset - Optional. Offset to read file, default value is 0.\n   * @param count - Optional. How many bytes to read, default will read from offset to the end.\n   * @param options - Optional. Options when reading file.\n   */\n  public async read(\n    offset: number = 0,\n    count?: number,\n    options: FileReadOptions = {},\n  ): Promise<FileReadResponse> {\n    return tracingClient.withSpan(\"DataLakeFileClient-read\", options, async (updatedOptions) => {\n      const rawResponse = await this.blockBlobClientInternal.download(offset, count, {\n        ...updatedOptions,\n        customerProvidedKey: toBlobCpkInfo(updatedOptions.customerProvidedKey),\n      });\n\n      const response = ParsePathGetPropertiesExtraHeaderValues(\n        rawResponse as FileReadResponse,\n      ) as FileReadResponse;\n      if (!isNodeLike && !response.contentAsBlob) {\n        response.contentAsBlob = rawResponse.blobBody;\n      }\n      response.fileContentMD5 = rawResponse.blobContentMD5;\n      response._response.parsedHeaders.fileContentMD5 =\n        rawResponse._response.parsedHeaders.blobContentMD5;\n      delete rawResponse.blobContentMD5;\n      delete rawResponse._response.parsedHeaders.blobContentMD5;\n\n      return response;\n    });\n  }\n\n  /**\n   * Uploads data to be appended to a file. Data can only be appended to a file.\n   * To apply perviously uploaded data to a file, call flush.\n   *\n   * @see https://learn.microsoft.com/rest/api/storageservices/datalakestoragegen2/path/update\n   *\n   * @param body - Content to be uploaded.\n   * @param offset - Append offset in bytes.\n   * @param length - Length of content to append in bytes.\n   * @param options - Optional. Options when appending data.\n   */\n  public async append(\n    body: HttpRequestBody,\n    offset: number,\n    length: number,\n    options: FileAppendOptions = {},\n  ): Promise<FileAppendResponse> {\n    options.conditions = options.conditions || {};\n    return tracingClient.withSpan(\"DataLakeFileClient-append\", options, async (updatedOptions) => {\n      ensureCpkIfSpecified(options.customerProvidedKey, this.isHttps);\n      return assertResponse<PathAppendDataHeaders, PathAppendDataHeaders>(\n        await this.pathContextInternal.appendData(body, {\n          ...updatedOptions,\n          pathHttpHeaders: {\n            contentMD5: options.transactionalContentMD5,\n          },\n          abortSignal: options.abortSignal,\n          position: offset,\n          contentLength: length,\n          leaseAccessConditions: options.conditions,\n          requestOptions: {\n            onUploadProgress: options.onProgress,\n          },\n          cpkInfo: options.customerProvidedKey,\n          flush: options.flush,\n          proposedLeaseId: options.proposedLeaseId,\n          leaseDuration: options.leaseDurationInSeconds,\n          leaseAction: options.leaseAction,\n        }),\n      );\n    });\n  }\n\n  /**\n   * Flushes (writes) previously appended data to a file.\n   *\n   * @param position - File position to flush.\n   *                          This parameter allows the caller to upload data in parallel and control the order in which it is appended to the file.\n   *                          It is required when uploading data to be appended to the file and when flushing previously uploaded data to the file.\n   *                          The value must be the position where the data is to be appended. Uploaded data is not immediately flushed, or written,\n   *                          to the file. To flush, the previously uploaded data must be contiguous, the position parameter must be specified and\n   *                          equal to the length of the file after all data has been written, and there must not be a request entity body included\n   *                          with the request.\n   * @param options - Optional. Options when flushing data.\n   */\n  public async flush(position: number, options: FileFlushOptions = {}): Promise<FileFlushResponse> {\n    options.conditions = options.conditions || {};\n    return tracingClient.withSpan(\"DataLakeFileClient-flush\", options, async (updatedOptions) => {\n      ensureCpkIfSpecified(options.customerProvidedKey, this.isHttps);\n      return assertResponse<PathFlushDataHeaders, PathFlushDataHeaders>(\n        await this.pathContextInternal.flushData({\n          ...updatedOptions,\n          position,\n          contentLength: 0,\n          leaseAccessConditions: options.conditions,\n          modifiedAccessConditions: options.conditions,\n          cpkInfo: options.customerProvidedKey,\n          proposedLeaseId: options.proposedLeaseId,\n          leaseDuration: options.leaseDurationInSeconds,\n          leaseAction: options.leaseAction,\n        }),\n      );\n    });\n  }\n\n  // high level functions\n\n  /**\n   * ONLY AVAILABLE IN NODE.JS RUNTIME.\n   *\n   * Uploads a local file to a Data Lake file.\n   *\n   * @param filePath - Full path of the local file\n   * @param options -\n   */\n  public async uploadFile(\n    filePath: string,\n    // Legacy, no way to fix the eslint error without breaking. Disable the rule for this line.\n    /* eslint-disable-next-line @azure/azure-sdk/ts-naming-options */\n    options: FileParallelUploadOptions = {},\n  ): Promise<FileUploadResponse> {\n    return tracingClient.withSpan(\n      \"DataLakeFileClient-uploadFile\",\n      options,\n      async (updatedOptions) => {\n        const size = (await fsStat(filePath)).size;\n        return this.uploadSeekableInternal(\n          (offset: number, contentSize: number) => {\n            return () =>\n              fsCreateReadStream(filePath, {\n                autoClose: true,\n                end: offset + contentSize - 1,\n                start: offset,\n              });\n          },\n          size,\n          updatedOptions,\n        );\n      },\n    );\n  }\n\n  /**\n   * Uploads a Buffer(Node.js)/Blob/ArrayBuffer/ArrayBufferView to a File.\n   *\n   * @param data - Buffer(Node), Blob, ArrayBuffer or ArrayBufferView\n   * @param options -\n   */\n  public async upload(\n    data: Buffer | Blob | ArrayBuffer | ArrayBufferView,\n    options: FileParallelUploadOptions = {},\n  ): Promise<FileUploadResponse> {\n    return tracingClient.withSpan(\"DataLakeFileClient-upload\", options, async (updatedOptions) => {\n      if (isNodeLike) {\n        let buffer: Buffer;\n        if (data instanceof Buffer) {\n          buffer = data;\n        } else if (data instanceof ArrayBuffer) {\n          buffer = Buffer.from(data);\n        } else {\n          data = data as ArrayBufferView;\n          buffer = Buffer.from(data.buffer, data.byteOffset, data.byteLength);\n        }\n\n        return this.uploadSeekableInternal(\n          (offset: number, size: number): Buffer => buffer.slice(offset, offset + size),\n          buffer.length,\n          updatedOptions,\n        );\n      } else {\n        const browserBlob = new Blob([data as ArrayBuffer]);\n        return this.uploadSeekableInternal(\n          (offset: number, size: number): Blob => browserBlob.slice(offset, offset + size),\n          browserBlob.size,\n          updatedOptions,\n        );\n      }\n    });\n  }\n\n  private async uploadSeekableInternal(\n    bodyFactory: (offset: number, count: number) => HttpRequestBody,\n    size: number,\n    options: FileParallelUploadOptions = {},\n  ): Promise<FileUploadResponse> {\n    return tracingClient.withSpan(\n      \"DataLakeFileClient-uploadData\",\n      options,\n      async (updatedOptions) => {\n        if (size > FILE_MAX_SIZE_BYTES) {\n          throw new RangeError(`size must be <= ${FILE_MAX_SIZE_BYTES}.`);\n        }\n\n        // Create the file.\n        const createRes = this.create({\n          abortSignal: options.abortSignal,\n          metadata: options.metadata,\n          permissions: options.permissions,\n          umask: options.umask,\n          conditions: options.conditions,\n          pathHttpHeaders: options.pathHttpHeaders,\n          customerProvidedKey: updatedOptions.customerProvidedKey,\n          tracingOptions: updatedOptions.tracingOptions,\n          encryptionContext: updatedOptions.encryptionContext,\n        });\n        // append() with empty data would return error, so do not continue\n        if (size === 0) {\n          return createRes;\n        } else {\n          await createRes;\n        }\n\n        // After the File is Create, Lease ID is the only valid request parameter.\n        options.conditions = { leaseId: options.conditions?.leaseId };\n\n        if (!options.chunkSize) {\n          options.chunkSize = Math.ceil(size / BLOCK_BLOB_MAX_BLOCKS);\n          if (options.chunkSize < FILE_UPLOAD_DEFAULT_CHUNK_SIZE) {\n            options.chunkSize = FILE_UPLOAD_DEFAULT_CHUNK_SIZE;\n          }\n        }\n        if (options.chunkSize < 1 || options.chunkSize > FILE_UPLOAD_MAX_CHUNK_SIZE) {\n          throw new RangeError(\n            `chunkSize option must be >= 1 and <= ${FILE_UPLOAD_MAX_CHUNK_SIZE}`,\n          );\n        }\n\n        if (!options.maxConcurrency) {\n          options.maxConcurrency = DEFAULT_HIGH_LEVEL_CONCURRENCY;\n        }\n        if (options.maxConcurrency <= 0) {\n          throw new RangeError(`maxConcurrency must be > 0.`);\n        }\n\n        if (!options.singleUploadThreshold) {\n          options.singleUploadThreshold = FILE_MAX_SINGLE_UPLOAD_THRESHOLD;\n        }\n        if (\n          options.singleUploadThreshold < 1 ||\n          options.singleUploadThreshold > FILE_MAX_SINGLE_UPLOAD_THRESHOLD\n        ) {\n          throw new RangeError(\n            `singleUploadThreshold option must be >= 1 and <= ${FILE_MAX_SINGLE_UPLOAD_THRESHOLD}`,\n          );\n        }\n\n        // When buffer length <= singleUploadThreshold, this method will use one append/flush call to finish the upload.\n        if (size <= options.singleUploadThreshold) {\n          await this.append(bodyFactory(0, size), 0, size, {\n            abortSignal: options.abortSignal,\n            conditions: options.conditions,\n            customerProvidedKey: updatedOptions.customerProvidedKey,\n            onProgress: options.onProgress,\n            tracingOptions: updatedOptions.tracingOptions,\n          });\n\n          return this.flush(size, {\n            abortSignal: options.abortSignal,\n            conditions: options.conditions,\n            close: options.close,\n            pathHttpHeaders: options.pathHttpHeaders,\n            customerProvidedKey: updatedOptions.customerProvidedKey,\n            tracingOptions: updatedOptions.tracingOptions,\n          });\n        }\n\n        const numBlocks: number = Math.floor((size - 1) / options.chunkSize) + 1;\n        if (numBlocks > BLOCK_BLOB_MAX_BLOCKS) {\n          throw new RangeError(\n            `The data's size is too big or the chunkSize is too small;` +\n              `the number of chunks must be <= ${BLOCK_BLOB_MAX_BLOCKS}`,\n          );\n        }\n\n        let transferProgress: number = 0;\n        const batch = new Batch(options.maxConcurrency);\n\n        for (let i = 0; i < numBlocks; i++) {\n          batch.addOperation(async (): Promise<any> => {\n            const start = options.chunkSize! * i;\n            const end = i === numBlocks - 1 ? size : start + options.chunkSize!;\n            const contentLength = end - start;\n            await this.append(bodyFactory(start, contentLength), start, contentLength, {\n              abortSignal: options.abortSignal,\n              conditions: options.conditions,\n              customerProvidedKey: updatedOptions.customerProvidedKey,\n              tracingOptions: updatedOptions.tracingOptions,\n            });\n\n            transferProgress += contentLength;\n            if (options.onProgress) {\n              options.onProgress({ loadedBytes: transferProgress });\n            }\n          });\n        }\n        await batch.do();\n\n        return this.flush(size, {\n          abortSignal: options.abortSignal,\n          conditions: options.conditions,\n          close: options.close,\n          pathHttpHeaders: options.pathHttpHeaders,\n          customerProvidedKey: updatedOptions.customerProvidedKey,\n          tracingOptions: updatedOptions.tracingOptions,\n        });\n      },\n    );\n  }\n\n  /**\n   * ONLY AVAILABLE IN NODE.JS RUNTIME.\n   *\n   * Uploads a Node.js Readable stream into a Data Lake file.\n   * This method will try to create a file, then starts uploading chunk by chunk.\n   * Please make sure potential size of stream doesn't exceed FILE_MAX_SIZE_BYTES and\n   * potential number of chunks doesn't exceed BLOCK_BLOB_MAX_BLOCKS.\n   *\n   * PERFORMANCE IMPROVEMENT TIPS:\n   * * Input stream highWaterMark is better to set a same value with options.chunkSize\n   *   parameter, which will avoid Buffer.concat() operations.\n   *\n   * @param stream - Node.js Readable stream.\n   * @param options -\n   */\n  public async uploadStream(\n    stream: Readable,\n    options: FileParallelUploadOptions = {},\n  ): Promise<FileUploadResponse> {\n    return tracingClient.withSpan(\n      \"DataLakeFileClient-uploadStream\",\n      options,\n      async (updatedOptions) => {\n        // Create the file\n        await this.create({\n          abortSignal: options.abortSignal,\n          metadata: options.metadata,\n          permissions: options.permissions,\n          umask: options.umask,\n          conditions: options.conditions,\n          pathHttpHeaders: options.pathHttpHeaders,\n          customerProvidedKey: options.customerProvidedKey,\n          tracingOptions: updatedOptions.tracingOptions,\n          encryptionContext: updatedOptions.encryptionContext,\n        });\n\n        // After the File is Create, Lease ID is the only valid request parameter.\n        options.conditions = { leaseId: options.conditions?.leaseId };\n\n        if (!options.chunkSize) {\n          options.chunkSize = FILE_UPLOAD_DEFAULT_CHUNK_SIZE;\n        }\n        if (options.chunkSize < 1 || options.chunkSize > FILE_UPLOAD_MAX_CHUNK_SIZE) {\n          throw new RangeError(\n            `chunkSize option must be >= 1 and <= ${FILE_UPLOAD_MAX_CHUNK_SIZE}`,\n          );\n        }\n        if (!options.maxConcurrency) {\n          options.maxConcurrency = DEFAULT_HIGH_LEVEL_CONCURRENCY;\n        }\n        if (options.maxConcurrency <= 0) {\n          throw new RangeError(`maxConcurrency must be > 0.`);\n        }\n\n        let transferProgress: number = 0;\n        const scheduler = new BufferScheduler(\n          stream,\n          options.chunkSize,\n          options.maxConcurrency,\n          async (body, length, offset) => {\n            await this.append(body, offset!, length, {\n              abortSignal: options.abortSignal,\n              conditions: options.conditions,\n              customerProvidedKey: options.customerProvidedKey,\n              tracingOptions: updatedOptions.tracingOptions,\n            });\n\n            // Update progress after block is successfully uploaded to server, in case of block trying\n            transferProgress += length;\n            if (options.onProgress) {\n              options.onProgress({ loadedBytes: transferProgress });\n            }\n          },\n          // concurrency should set a smaller value than maxConcurrency, which is helpful to\n          // reduce the possibility when a outgoing handler waits for stream data, in\n          // this situation, outgoing handlers are blocked.\n          // Outgoing queue shouldn't be empty.\n          Math.ceil((options.maxConcurrency / 4) * 3),\n        );\n        await scheduler.do();\n\n        return this.flush(transferProgress, {\n          abortSignal: options.abortSignal,\n          conditions: options.conditions,\n          close: options.close,\n          pathHttpHeaders: options.pathHttpHeaders,\n          customerProvidedKey: options.customerProvidedKey,\n          tracingOptions: updatedOptions.tracingOptions,\n        });\n      },\n    );\n  }\n\n  /**\n   * ONLY AVAILABLE IN NODE.JS RUNTIME.\n   *\n   * Reads a Data Lake file in parallel to a buffer.\n   * Offset and count are optional, pass 0 for both to read the entire file.\n   *\n   * Warning: Buffers can only support files up to about one gigabyte on 32-bit systems or about two\n   * gigabytes on 64-bit systems due to limitations of Node.js/V8. For files larger than this size,\n   * consider {@link readToFile}.\n   *\n   * @param buffer - Buffer to be fill, must have length larger than count\n   * @param offset - From which position of the Data Lake file to read\n   * @param count - How much data to be read. Will read to the end when passing undefined\n   * @param options -\n   */\n  public async readToBuffer(\n    buffer: Buffer,\n    offset?: number,\n    count?: number,\n    options?: FileReadToBufferOptions,\n  ): Promise<Buffer>;\n\n  /**\n   * ONLY AVAILABLE IN NODE.JS RUNTIME\n   *\n   * Reads a Data Lake file in parallel to a buffer.\n   * Offset and count are optional, pass 0 for both to read the entire file\n   *\n   * Warning: Buffers can only support files up to about one gigabyte on 32-bit systems or about two\n   * gigabytes on 64-bit systems due to limitations of Node.js/V8. For files larger than this size,\n   * consider {@link readToFile}.\n   *\n   * @param offset - From which position of the Data Lake file to read(in bytes)\n   * @param count - How much data(in bytes) to be read. Will read to the end when passing undefined\n   * @param options -\n   */\n  public async readToBuffer(\n    offset?: number,\n    count?: number,\n    options?: FileReadToBufferOptions,\n  ): Promise<Buffer>;\n\n  public async readToBuffer(\n    bufferOrOffset?: Buffer | number,\n    offsetOrCount?: number,\n    countOrOptions?: FileReadToBufferOptions | number,\n    optOptions: FileReadToBufferOptions = {},\n  ): Promise<Buffer> {\n    let buffer: Buffer | undefined = undefined;\n    let offset = 0;\n    let count = 0;\n    let options = optOptions;\n    if (bufferOrOffset instanceof Buffer) {\n      buffer = bufferOrOffset;\n      offset = offsetOrCount || 0;\n      count = typeof countOrOptions === \"number\" ? countOrOptions : 0;\n    } else {\n      offset = typeof bufferOrOffset === \"number\" ? bufferOrOffset : 0;\n      count = typeof offsetOrCount === \"number\" ? offsetOrCount : 0;\n      options = (countOrOptions as FileReadToBufferOptions) || {};\n    }\n    return tracingClient.withSpan(\n      \"DataLakeFileClient-readToBuffer\",\n      options,\n      async (updatedOptions) => {\n        if (buffer) {\n          return this.blockBlobClientInternal.downloadToBuffer(buffer, offset, count, {\n            ...options,\n            maxRetryRequestsPerBlock: options.maxRetryRequestsPerChunk,\n            blockSize: options.chunkSize,\n            customerProvidedKey: toBlobCpkInfo(options.customerProvidedKey),\n            tracingOptions: updatedOptions.tracingOptions,\n          });\n        } else {\n          return this.blockBlobClientInternal.downloadToBuffer(offset, count, {\n            ...options,\n            maxRetryRequestsPerBlock: options.maxRetryRequestsPerChunk,\n            blockSize: options.chunkSize,\n            customerProvidedKey: toBlobCpkInfo(options.customerProvidedKey),\n            tracingOptions: updatedOptions.tracingOptions,\n          });\n        }\n      },\n    );\n  }\n\n  /**\n   * ONLY AVAILABLE IN NODE.JS RUNTIME.\n   *\n   * Downloads a Data Lake file to a local file.\n   * Fails if the the given file path already exits.\n   * Offset and count are optional, pass 0 and undefined respectively to download the entire file.\n   *\n   * @param filePath -\n   * @param offset - From which position of the file to download.\n   * @param count - How much data to be downloaded. Will download to the end when passing undefined.\n   * @param options - Options to read Data Lake file.\n   * @returns The response data for file read operation,\n   *                                      but with readableStreamBody set to undefined since its\n   *                                      content is already read and written into a local file\n   *                                      at the specified path.\n   */\n  public async readToFile(\n    filePath: string,\n    offset: number = 0,\n    count?: number,\n    options: FileReadOptions = {},\n  ): Promise<FileReadResponse> {\n    return tracingClient.withSpan(\n      \"DataLakeFileClient-readToFile\",\n      options,\n      async (updatedOptions) => {\n        const rawResposne = await this.blockBlobClientInternal.downloadToFile(\n          filePath,\n          offset,\n          count,\n          {\n            ...updatedOptions,\n            customerProvidedKey: toBlobCpkInfo(options.customerProvidedKey),\n          },\n        );\n\n        const response = ParsePathGetPropertiesExtraHeaderValues(\n          rawResposne as FileReadResponse,\n        ) as FileReadResponse;\n        return response;\n      },\n    );\n  }\n\n  /**\n   * Quick query for a JSON or CSV formatted file.\n   *\n   * Example usage (Node.js):\n   *\n   * ```ts snippet:ReadmeSampleQueryFile_Node\n   * import { DataLakeServiceClient } from \"@azure/storage-file-datalake\";\n   *\n   * const account = \"<account>\";\n   * const sas = \"<sas token>\";\n   * const datalakeServiceClient = new DataLakeServiceClient(\n   *   `https://${account}.dfs.core.windows.net${sas}`,\n   * );\n   *\n   * const fileSystemName = \"<file system name>\";\n   * const fileName = \"<file name>\";\n   * const fileSystemClient = datalakeServiceClient.getFileSystemClient(fileSystemName);\n   * const fileClient = fileSystemClient.getFileClient(fileName);\n   *\n   * // Query and convert a file to a string\n   * const queryResponse = await fileClient.query(\"select * from BlobStorage\");\n   * if (queryResponse.readableStreamBody) {\n   *   const responseBuffer = await streamToBuffer(queryResponse.readableStreamBody);\n   *   const downloaded = responseBuffer.toString();\n   *   console.log(`Query file content: ${downloaded}`);\n   * }\n   *\n   * async function streamToBuffer(readableStream: NodeJS.ReadableStream): Promise<Buffer> {\n   *   return new Promise((resolve, reject) => {\n   *     const chunks: Buffer[] = [];\n   *     readableStream.on(\"data\", (data) => {\n   *       chunks.push(data instanceof Buffer ? data : Buffer.from(data));\n   *     });\n   *     readableStream.on(\"end\", () => {\n   *       resolve(Buffer.concat(chunks));\n   *     });\n   *     readableStream.on(\"error\", reject);\n   *   });\n   * }\n   * ```\n   *\n   * @param query -\n   * @param options -\n   */\n  public async query(query: string, options: FileQueryOptions = {}): Promise<FileReadResponse> {\n    return tracingClient.withSpan(\"DataLakeFileClient-query\", options, async (updatedOptions) => {\n      const rawResponse = await this.blockBlobClientInternal.query(query, {\n        ...updatedOptions,\n        customerProvidedKey: toBlobCpkInfo(options.customerProvidedKey),\n      });\n      const response = rawResponse as FileReadResponse;\n      if (!isNodeLike && !response.contentAsBlob) {\n        response.contentAsBlob = rawResponse.blobBody;\n      }\n      response.fileContentMD5 = rawResponse.blobContentMD5;\n      response._response.parsedHeaders.fileContentMD5 =\n        rawResponse._response.parsedHeaders.blobContentMD5;\n      delete rawResponse.blobContentMD5;\n      delete rawResponse._response.parsedHeaders.blobContentMD5;\n      return response;\n    });\n  }\n\n  /**\n   * Sets an expiry time on a file, once that time is met the file is deleted.\n   *\n   * @param mode -\n   * @param options -\n   */\n  public async setExpiry(\n    mode: FileExpiryMode,\n    options: FileSetExpiryOptions = {},\n  ): Promise<FileSetExpiryResponse> {\n    return tracingClient.withSpan(\n      \"DataLakeFileClient-setExpiry\",\n      options,\n      async (updatedOptions) => {\n        let expiresOn: string | undefined = undefined;\n        if (mode === \"RelativeToNow\" || mode === \"RelativeToCreation\") {\n          if (!options.timeToExpireInMs) {\n            throw new Error(`Should specify options.timeToExpireInMs when using mode ${mode}.`);\n          }\n          // MINOR: need check against <= 2**64, but JS number has the precision problem.\n          expiresOn = Math.round(options.timeToExpireInMs).toString();\n        }\n\n        if (mode === \"Absolute\") {\n          if (!options.expiresOn) {\n            throw new Error(`Should specify options.expiresOn when using mode ${mode}.`);\n          }\n          const now = new Date();\n          if (!(options.expiresOn!.getTime() > now.getTime())) {\n            throw new Error(\n              `options.expiresOn should be later than now: ${now.toUTCString()} when using mode ${mode}, but is ${options.expiresOn?.toUTCString()}`,\n            );\n          }\n          expiresOn = options.expiresOn!.toUTCString();\n        }\n\n        const adaptedOptions = { ...options, expiresOn };\n        return assertResponse<PathSetExpiryHeaders, PathSetExpiryHeaders>(\n          await this.pathContextInternalToBlobEndpoint.setExpiry(mode, {\n            ...adaptedOptions,\n            tracingOptions: updatedOptions.tracingOptions,\n          }),\n        );\n      },\n    );\n  }\n\n  /**\n   * Only available for clients constructed with a shared key credential.\n   *\n   * Generates a Service Shared Access Signature (SAS) URI based on the client properties\n   * and parameters passed in. The SAS is signed by the shared key credential of the client.\n   *\n   * @see https://learn.microsoft.com/rest/api/storageservices/constructing-a-service-sas\n   *\n   * @param options - Optional parameters.\n   * @returns The SAS URI consisting of the URI to the resource represented by this client, followed by the generated SAS token.\n   */\n  public generateSasUrl(options: FileGenerateSasUrlOptions): Promise<string> {\n    return new Promise((resolve) => {\n      if (!(this.credential instanceof StorageSharedKeyCredential)) {\n        throw RangeError(\n          \"Can only generate the SAS when the client is initialized with a shared key credential\",\n        );\n      }\n\n      const sas = generateDataLakeSASQueryParameters(\n        {\n          fileSystemName: this.fileSystemName,\n          pathName: this.name,\n          ...options,\n        },\n        this.credential,\n      ).toString();\n\n      resolve(appendToURLQuery(this.url, sas));\n    });\n  }\n\n  /**\n   * Only available for clients constructed with a shared key credential.\n   *\n   * Generates string to sign for a Service Shared Access Signature (SAS) URI based on the client properties\n   * and parameters passed in. The SAS is signed by the shared key credential of the client.\n   *\n   * @see https://learn.microsoft.com/rest/api/storageservices/constructing-a-service-sas\n   *\n   * @param options - Optional parameters.\n   * @returns The SAS URI consisting of the URI to the resource represented by this client, followed by the generated SAS token.\n   */\n  /* eslint-disable-next-line @azure/azure-sdk/ts-naming-options*/\n  public generateSasStringToSign(options: FileGenerateSasUrlOptions): string {\n    if (!(this.credential instanceof StorageSharedKeyCredential)) {\n      throw RangeError(\n        \"Can only generate the SAS when the client is initialized with a shared key credential\",\n      );\n    }\n\n    return generateDataLakeSASQueryParametersInternal(\n      {\n        fileSystemName: this.fileSystemName,\n        pathName: this.name,\n        ...options,\n      },\n      this.credential,\n    ).stringToSign;\n  }\n\n  /**\n   * Generates a Service Shared Access Signature (SAS) URI based on the client properties\n   * and parameters passed in. The SAS is signed by the input user delegation key.\n   *\n   * @see https://learn.microsoft.com/rest/api/storageservices/constructing-a-service-sas\n   *\n   * @param options - Optional parameters.\n   * @param userDelegationKey - Return value of `blobServiceClient.getUserDelegationKey()`\n   * @returns The SAS URI consisting of the URI to the resource represented by this client, followed by the generated SAS token.\n   */\n  public generateUserDelegationSasUrl(\n    options: FileGenerateSasUrlOptions,\n    userDelegationKey: UserDelegationKey,\n  ): Promise<string> {\n    return new Promise((resolve) => {\n      const sas = generateDataLakeSASQueryParameters(\n        {\n          fileSystemName: this.fileSystemName,\n          pathName: this.name,\n          ...options,\n        },\n        userDelegationKey,\n        this.accountName,\n      ).toString();\n\n      resolve(appendToURLQuery(this.url, sas));\n    });\n  }\n\n  /**\n   * Generates string to sign for a Service Shared Access Signature (SAS) URI based on the client properties\n   * and parameters passed in. The SAS is signed by the input user delegation key.\n   *\n   * @see https://learn.microsoft.com/rest/api/storageservices/constructing-a-service-sas\n   *\n   * @param options - Optional parameters.\n   * @param userDelegationKey - Return value of `blobServiceClient.getUserDelegationKey()`\n   * @returns The SAS URI consisting of the URI to the resource represented by this client, followed by the generated SAS token.\n   */\n\n  public generateUserDelegationSasStringToSign(\n    options: FileGenerateSasUrlOptions,\n    userDelegationKey: UserDelegationKey,\n  ): string {\n    return generateDataLakeSASQueryParametersInternal(\n      {\n        fileSystemName: this.fileSystemName,\n        pathName: this.name,\n        ...options,\n      },\n      userDelegationKey,\n      this.accountName,\n    ).stringToSign;\n  }\n}\n"]}